#ifndef FTL_STRING
#define FTL_STRING

#include "iterator"
#include "utility"
#include <algorithm>
#include <exception>
#include <stdexcept>

namespace ftl {
	template <
		typename CharT,
		class Allocator = std::allocator<CharT>
	>
	class basic_string {
	public:
		using value_type = CharT;
		using allocator_type = Allocator;
		using size_type = allocator_traits::size_type;
		using difference_type = allocator_traits::difference_type;
		using reference = CharT&;
		using const_reference = const CharT&;
		using pointer = CharT*;
		using const_pointer = const CharT*;
		struct iterator;
		struct const_iterator;
		using reverse_iterator = ftl::reverse_iterator<iterator>;
		using const_reverse_iterator = ftl::const_reverse_iterator<iterator>;

		static const size_type npos = -1;

		constexpr explicit basic_string(const Allocator& alloc) noexcept
		: b_(empty_str_), s_(0), c_(0), a_(alloc)
		{}

		constexpr basic_string() noexcept : basic_string(Allocator()) {}

		constexpr basic_string(size_type count,
			CharT ch, const Allocator& alloc = Allocator())
		: s_(count), c_(count + 1), a_(alloc)
		{
			b_ = s_ < sbsize_ ? sb_ : allocator_traits::allocate(a_, c_);
			std::fill_n(b_, s_, ch);
            b_[s_] = 0;
		}

		constexpr basic_string(const basic_string& other, size_type pos,
			const Allocator& alloc = Allocator())
		: a_(alloc)
		{
			s_ = other.size() - pos;
			c_ = s_ + 1;
			b_ = s_ < sbsize_ ? sb_ : allocator_traits::allocate(a_, c_);
			
			strcpy(b_, other.b_ + pos);
            b_[s_] = 0;
		}

		constexpr basic_string(const basic_string& other, size_type pos,
			size_type count,
			const Allocator& alloc = Allocator())
		: a_(alloc)
		{
			s_ = other.size() - pos - count;
			c_ = s_ + 1;
			b_ = c_ < sbsize_ ? sb_ : allocator_traits::allocate(a_, c_);
			
			strncpy(b_, other.b_ + pos, count);
            b_[s_] = 0;
		}

		constexpr basic_string(const CharT* s, size_type count,
		                        const Allocator& alloc = Allocator())
		: a_(alloc)
        {
            s_ = strlen(s);
            c_ = s_ + 1;
            b_ = c_ < sbsize_ ? sb_ : allocator_traits::allocate(a_, c_);
            strncpy(b_, s, count);
            b_[s_] = 0;
        }

        constexpr basic_string(const CharT* s,
                               const Allocator& alloc = Allocator())
        : a_(alloc)
        {
            s_ = strlen(s);
            c_ = s_ + 1;
            b_ = c_ < sbsize_ ? sb_ : allocator_traits::allocate(a_, c_);
            strcpy(b_, s);
            b_[s_] = 0;
        }

        template <typename InputIt>
        constexpr basic_string(InputIt first, InputIt last,
            const Allocator& alloc = Allocator())
        : a_(alloc)
        {
            s_ = ftl::distance(last - first);
            c_ = s + 1;

            b_ = c_ < sbsize_ ? sb_ : allocator_traits::allocate(a_, c_);
            std::copy(first, last, b_);
            b_[s_] = 0;
        }

        constexpr basic_string(const basic_string& other,
            const Allocator& alloc)
        : s_(other.s_), c_(other.c_), a_(alloc)
        {
            b_ = c_ < sbsize_ ? sb_ : allocator_traits::allocate(b_, c_);
            strcpy(b_, other.b_);
            b_[s_] = 0;
        }

        constexpr basic_string(const basic_string& other)
        : s_(other.s_), c_(other.c_), a_(other.a_)
        {
            b_ = c_ < sbsize_ ? sb_ : allocator_traits::allocate(b_, c_);
            strcpy(b_, other.b_);
            b_[s_] = 0;
        }

        constexpr basic_string(basic_string&& other, const Allocator& alloc)
        : b_(other.b_), sb_(std::move(other.sb_)), s_(other.s_),
			c_(other.c_), a_(alloc)
        {
            other.b_ = nullptr;
        }

        constexpr basic_string(basic_string&& other)
	    : b_(other.b_), sb_(std::move(other.sb_)), s_(other.s_), c_(other.c_),
            a_(Allocator())
        {
            other.b_ = nullptr;
        }

		constexpr basic_string(std::initializer_list<CharT> init,
			const Allocator& alloc = Allocator())
		: s_(init.size()), c_(s_ + 1), a_(alloc)
		{
            b_ = c_ < sbsize_ ? sb_ : allocator_traits::allocate(a_, c_);
            std::copy(init.begin(), init.end(), b_);
            b_[s_] = 0;
		}

		~basic_string()
		{
			if (c_ > sbsize_) allocator_traits::deallocate(a_, b_, c_);
		}

		constexpr basic_string& operator=(const basic_string& str)
		{
            return str;
		}

		[[nodiscard]] constexpr bool empty() const noexcept
		{
			return (c_ == 0 || s_ == 0 || b_ == empty_str_
					|| begin() == end());
		}

		constexpr size_type size() const noexcept
		{
			return s_;
		}

		constexpr size_type length() const noexcept
		{
			return s_;
		}

		constexpr static size_type max_size() noexcept
		{
			return std::numeric_limits<std::size_t>::max() / sizeof(CharT);
		}

		constexpr size_type capacity() const noexcept
		{
			return c_;
		}

		constexpr reference front()
		{
			return *b_;
		}

		constexpr const_reference front() const
		{
			return *b_;
		}

		constexpr reference back()
		{
			return *(b_ + s_ - 1);
		}

		constexpr const_reference back() const
		{
			return *(b_ + s_ - 1);
		}

		constexpr pointer data() noexcept
        {
		    return b_;
        }

        constexpr const_pointer data() const noexcept
        {
		    return b_;
        }

        constexpr const_pointer c_str() const noexcept
        {
		    return b_;
        }



		constexpr iterator begin() noexcept
		{
			return iterator(b_);
		}

		constexpr const_iterator begin() const noexcept
		{
			return const_iterator(b_);
		}

		constexpr const_iterator cbegin() const noexcept
		{
			return const_iterator(b_);
		}

		constexpr iterator end() noexcept
		{
			return iterator(b_ + s_);
		}

		constexpr const_iterator end() const noexcept
		{
			return const_iterator(b_ + s_);
		}

		constexpr const_iterator cend() const noexcept
		{
			return const_iterator(b_ + s_);
		}

		constexpr reverse_iterator rbegin() noexcept
        {
		    return reverse_iterator<iterator>(b_ + _s);
        }

        constexpr const_reverse_iterator rbegin() const noexcept
        {
		    return const_reverse_iterator(b_ + s_);
        }

        constexpr const_reverse_iterator crbegin() const noexcept
        {
		    return const_reverse_iterator(b_ + s_);
        }

        constexpr reverse_iterator rend() noexcept
        {
		    return reverse_iterator(b_ - 1);
        }

        constexpr const_reverse_iterator rend() const noexcept
        {
		    return const_reverse_iterator(b_ - 1);
        }

        constexpr const_reverse_iterator crend() const noexcept
        {
		    return const_reverse_iterator(b_ - 1);
        }

		constexpr void reserve(size_type new_cap)
		{
			if (new_cap > max_size())
				throw std::length_error(
					"error: string capacity exceeds system limits"
			);
			if (new_cap <= c_) return;

			c_ = new_cap;
			auto tmp = allocator_traits::allocate(a_, c_);
			strcpy(tmp, b_);
			b_ = tmp;
			b_[s_ + 1] = 0;
			
			allocator_traits::deallocate(a_, tmp, c_);
		}

		struct iterator : public const_iterator {
            using iterator_category = random_access_iterator_tag;
            using difference_type = std::ptrdiff_t;
            using value_type = T;
            using reference = T&;
            using const_reference = const T&;
            using pointer = T*;
            using const_pointer = const T*;

            constexpr iterator() = default;

            constexpr explicit iterator(pointer ptr) : ptr_(ptr) {}

            constexpr explicit iterator(const_pointer ptr)
                    : ptr_(const_cast<pointer>(ptr))
            {}

            constexpr iterator(const iterator& other)
                    : ptr_(other.ptr_)
            {}

            constexpr iterator(iterator&& other) noexcept
                    : ptr_(other.ptr_)
            {}

            constexpr iterator& operator=(const iterator& other)
            {
                if (this == &other) return *this;
                iterator copy(other);
                copy.swap(*this);
                return *this;
            }

            constexpr iterator& operator=(iterator&& other) noexcept
            {
                if (this == &other) return *this;
                iterator copy(std::move(other));
                copy.swap(*this);
                return *this;
            }

            constexpr iterator& operator++()
            {
                ++ptr_;
                return *this;
            }

            constexpr const iterator& operator++() const
            {
                ++ptr_;
                return *this;
            }

            constexpr const iterator operator++(int) const
            {
                iterator tmp = *this;
                ++(*this);
                return tmp;
            }

            constexpr iterator& operator--()
            {
                --ptr_;
                return *this;
            }

            constexpr const iterator& operator--() const
            {
                --ptr_;
                return *this;
            }

            constexpr const iterator operator--(int)
            {
                iterator tmp = *this;
                --(*this);
                return tmp;
            }

            constexpr reference operator*()
            {
                return *ptr_;
            }

            constexpr const_reference operator*() const
            {
                return *ptr_;
            }

            constexpr bool operator==(const iterator& other) const
            {
                return ptr_ == other.ptr_;
            }

            constexpr bool operator!=(const iterator& other) const
            {
                return ptr_ != other.ptr_;
            }

            constexpr void swap(iterator& other)
            {
                ftl::swap(other.ptr_, ptr_);
            }

            friend constexpr iterator operator+(const iterator& iter, int n)
            {
                return iterator(iter.ptr_ + n);
            }

            friend constexpr iterator operator-(const iterator& iter, int n)
            {
                return iterator(iter.ptr_ - n);
            }

            friend constexpr iterator operator+(const iterator& iter, size_t n)
            {
                return iterator(iter.ptr_ + n);
            }

            friend constexpr iterator operator-(const iterator& iter, size_t n)
            {
                return iterator(iter.ptr_ - n);
            }

        protected:
            pointer ptr_;
        };

        struct const_iterator {
            using iterator_category = random_access_iterator_tag;
            using difference_type = std::ptrdiff_t;
            using value_type = T;
            using reference = T&;
            using const_reference = const T&;
            using pointer = T*;
            using const_pointer = const T*;

            constexpr const_iterator() = default;

            constexpr explicit const_iterator(pointer ptr) : ptr_(ptr) {}

            constexpr explicit const_iterator(const_pointer ptr)
                    : ptr_(const_cast<pointer>(ptr))
            {}

            constexpr const_iterator(const const_iterator& other)
                    : ptr_(other.ptr_)
            {}

            constexpr const_iterator(const_iterator&& other) noexcept
                    : ptr_(other.ptr_)
            {}

            constexpr const_iterator& operator=(const const_iterator& other)
            {
                if (this == &other) return *this;
                const_iterator copy(other);
                copy.swap(*this);
                return *this;
            }

            constexpr const_iterator& operator=(const_iterator&& other) noexcept
            {
                if (this == &other) return *this;
                iterator copy(std::move(other));
                copy.swap(*this);
                return *this;
            }


            constexpr const const_iterator& operator++()
            {
                ++ptr_;
                return *this;
            }

            constexpr const const_iterator operator++(int)
            {
                const_iterator tmp = *this;
                ++(*this);
                return tmp;
            }

            constexpr const const_iterator& operator--()
            {
                --ptr_;
                return *this;
            }

            constexpr const const_iterator operator--(int)
            {
                const_iterator tmp = *this;
                --(*this);
                return tmp;
            }

            constexpr const_reference operator*() const
            {
                return *ptr_;
            }

            constexpr bool operator==(const const_iterator& other) const
            {
                return ptr_ == other.ptr_;
            }

            constexpr bool operator!=(const const_iterator& other) const
            {
                return ptr_ != other.ptr_;
            }

            constexpr void swap(const_iterator& other)
            {
                ftl::swap(other.ptr_, ptr_);
            }

            friend constexpr const_iterator
            operator+(const const_iterator& iter, int n)
            {
                return const_iterator(iter.ptr_ + n);
            }

            friend constexpr const_iterator
            operator-(const const_iterator& iter, int n)
            {
                return const_iterator(iter.ptr_ - n);
            }

            friend constexpr const_iterator
            operator+(const const_iterator& iter, size_t n)
            {
                return const_iterator(iter.ptr_ + n);
            }

            friend constexpr const_iterator
            operator-(const const_iterator& iter, size_t n)
            {
                return const_iterator(iter.ptr_ - n);
            }

        protected:
            pointer ptr_;
        };

	private:
		using allocator_traits = std::allocator_traits<Allocator>;
		static constexpr size_t sbsize_ = 30;
		static const CharT* empty_str_ = "\0";
		CharT b_;
		CharT sb_[sbsize_];
		size_type s_;
		size_type c_;
		Allocator a_;
	};
}

#endif
